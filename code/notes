MPS-Shark:

Zone map init:
  allocate all 32 zones thus, so every 8-stripe window has some of every zoneset:
  b    80        00         00        01
  0    10        10         10        10
  1    08        08         08        08
  2    67        E7         E7        E6
    b2201222  22201222   22201222  2220122b
         ---  -----
  0 and 1 each get 4/32 = 1/8
  2 (topgen) gets 22/32 = 69%

Zone size:
  Tell GR to set _growth to 400 / 5 = 80MB, not arena / 8.

Full rate:
  Make M = 0.25 S, not 2.5 S!
  In both trigger condition and finishingTime calc.

VMem limit:
  soft and hard required.  soft might be simply checked by ArenaAvail?
  code interface function with (param_code, param_value), for easy future changes




================ NOTES; CONSIDER ADDING THESE TO DESIGN DOCS ==================


-------------------- notes: simple chunk return --------------------

____PRIMARY____

The primary chunk is used specially:

1. Arenacl requires a chunk to store the ArenaStruct in.  (Whereas arenavm gets storage by simply mapping a new page).  Therefore destroying the primary chunk would (in general) destroy the arena.

2. there's a field arena->primary that stores a pointer to the primary chunk.  If the primary chunk ever goes away (eg. at ArenaFinish), this pointer must be nulled out so it is not left dangling.

3. PageSize is known by chunks, not the arena.  When arena needs to know page size, it asks the primary chunk.

4. Various *Check functions only bother to check the primary chunk, and ignore other chunks.



______NOTES ON CHUNK_CREATE________
VMArenaInit
  VMChunkCreate
vmArenaExtend
  VMChunkCreate

VMChunkCreate [arenavm.c]
  VMCreate [

- normal:
Create
  alloc
  Init
    <class>Init

- arena:
ACreate
  VMAInit
    alloc VMAS, contains AS
    AInit
      init AS fields
    init VMAS fields
    - AS and VMAS fields are set
    VMChunkCreate
      VMCreate(size) - alloc big chunk of vmem!
      BootBlockInit
      alloc(VMChunkStruct) (contains ChunkStruct)
      map(VMChunkStruct)
      ChunkInit
        ChunkStruct fields
        RingAppend(&arena->chunkRing, &chunk->chunkRing)
        alloc(aBPageIsAllocated "allocTable")
        VMChunkInit
          alloc(aBPSGIsMapped "pageTableMapped")
          alloc(aBPSGHasNoSpares "noSparePages")
          map(up to here)
          res(pTM)
          res(nSP)
        alloc(aPS "pageTable")
        allocBase = iPageFirstUseable
        res(aT)
        sig(Chunk)
      sig(VMChunk)
    primary = chunk
    zoneShift = SizeFloorLog2(chunkSize >> MPS_WORD_SHIFT);
  alignment = ChunkPageSize(arena->primary)
  ChunkEncache(arena, arena->primary);

      --- chunk contents:
        VMChunkStruct (contains ChunkStruct)
        
        /* for each page of allocatable memory: 1 Bit + 1 PS(PageStruct) */

        aB_perPage_IsAllocated "allocTable"

        /* for each PSG (PageStructGroup) (= as many PSs as fit into 1 page): 2 Bits */

        aB_perPSG_IsMapped "pageTableMapped"
        aB_perPSG_HasNoSpares "noSparePages"

        (---- memory up to here is always mapped ----)

        aPS_perPage "pageTable"
      
        (---- iPage_FirstUseable "allocBase" is here ----)
      ---
      

$Id$
