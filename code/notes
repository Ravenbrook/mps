mps_arena_tranform_objects

____Design____

The client's old->new table must contain managed refs (otherwise might get stale if a flip happens while client is assembling the table).  This means it is part of the object graph.  After a successful transform, all the old refs in this table will have been updated too, so it will look like a new->new table!  This had better not happen *during* the trace, so copy the entire table into the Control pool, and use that copy, not the client-provided one.

Park first.

(Rejected) Unwinding: if we have started a trace but found an ambig (non-updateable) ref to an old object, how do we abort the trace?  We don't.  (Too messy: there may be things like nailboards allocated).  Rejected.

Don't unwind: do trace-band Ambig, checking each fixed ref against the old list.  At the end of trace-band Ambig, if we ambiguously-fixed any old-list ref, then we cannot transform, but we *continue* the trace with transforming "off": it is just a non-transforming collection.  Whereas if we did not encounter any old-ref, then we have a green light for transforming (because all remaining refs are updateable), so we enter trace-band Exact with transforming "on".

Optimisations (whiteset etc) might prevent fix fixing.  What are these optimisations?  How do we turn them off appropriately?  Condemn segs holding all old objects should do it correctly, cf. traceStartCollectAll() for a seg-by-seg Whiten operation.

Intercept fix.  Function called is (ss)->fix, and is either TraceFix or TraceFixEmergency.

TraceStruct could know the fix function for this trace.  Aha, but Scan is for a whole TraceSet, not just a single trace.  How is ScanStateInit called?

Double-update: intercept fix, replace old by new, and continue to fix the new ref.  New may itself be condemned and so move (eg. if it's on same seg as an old).  

Will this upset any ref/summary asserts?

Emergency mode.  What happens if we enter emergency mode during the transform trace?  During a double-update?  See "if Fix fails, ref must be unchanged" in TraceFix().

(Rejected) Instead of double-update, how about overwriting old-obj with a forwarding pointer to new-obj.  Requires double snap-out (as would, I think, be required for multiple traces).  But only PoolAMC formats expect to use fwd/move & isfwd/isMoved, and only PoolAMC resolves forwarding pointers.  So would only support olds in PoolAMC.  Rejected.

Is it thread-safe?  If thread 1 is about to call transform(), but just after it pushes args on the stack it gets preempted and thread 2 starts and triggers a new trace.  Yup, should be ok.

Buffers: what if there's an old ptr in a buffer (allocation point)?

How can TraceAddWhite fail?  Basically it can't currently, apart from ResUNIMPL.  Ah, but allocing OldNewStructs in ControlPool can fail.


____Better stack scan____

__stack code naming gripes__

<http://info.ravenbrook.com/mail/2010/11/26/18-30-15/0/>

(I've had to write this, just to get the concepts straight in my own mind.  I'm not aiming to get at anyone.)

The current naming of this stuff is just horrible.

What we actually have is:
 - the concept of a thread;
 - the concept of the MPS datastructure associated with a thread, which stores some data about it, and is used to suspend and resume it;
 - the concept of the values directly accessible to the mutator from the context of a particular thread.

These should be called:
 - "Thread"
 - "Thr"
 - "ThreadContext"

Because Thr does not have any concept of containing references, it does not store stackBot.

ThreadContext is never called that currently; it is abbreviated, and very inconsistently: sometimes "reg", sometimes "stack", and sometimes "Thread"!  ThreadContext stores stackBot.

What complexity!  Maintaining separate concepts of Thr-for-suspend/resume, and ThreadContext-for-scanning -- is it worth it?  Is there a reason?  (For the rest of this email I assume this distinction remains).


Additionally, there are two situations where distinctions among threads are important:
 - recognising the thread that has entered the MPS (ArenaEnter), as distinct from all other threads;
 - implicitly referring to the current (running) thread, as distinct from some explicitly named thread.


Specific gripes:

The names "mps_thread_reg" and "...dereg" are awful -- in this case the text "reg" means register in the sense of make-a-record-of, not register in the sense of a hardware CPU register.  The first function should create a "Thr" (an MPS datastructure), and is implicitly referring to the running thread that makes the call.  The function name should reflect that, eg. "mps_thr_create_current".  Pair with "mps_thr_destroy".

The corresponding MPS-internal datastructure should be renamed "Thr" or "ThreadRecord".  It is not synonymous with "thread".

"mps_root_create_reg" should be "mps_root_create_threadcontext".  It should take a scanning function "mps_threadcontext_scan_t", not "mps_reg_scan_t".

"mps_stack_scan_ambig" should be "mps_threadcontext_scan", and means just what that new name says: scan for all the refs that can be found within the context of the specified thread.  It is a public name for the internal ThreadScan() function, which should be renamed ThreadContextScan().

When the thread whose context is to be scanned is different from the current thread, ThreadContextScan() (in th*.c) uses three sources of information: the "stackBot" value it gets as an argument (which was retrieved from the ThreadContext root), the "Thr" datastructure, and thread-library routines, to find and scan that thread's stack and registers.

When the thread whose context is to be scanned is *the same as* the current thread, ThreadContextScan() (in th*.c) calls "StackScan()".

"StackScan()", and the source files "ss*.c", are awfully named.  What they actually mean is ThreadContextScanCurrent(), ie. scan the context (stack, regs, etc) of the current thread, which will also be the thread that has entered the MPS (via ArenaEnter), and which has a whole bunch of MPS debris littering the stack.  This function, and the ss*.c source files, are completely bypassed when the thread whose context is to be scanned is different from the current thread.

rhsk

__END__

We need a better stack scan for the thread that enters the MPS and sets up the transform, because in the process of setting it up the MPS leaves stack-litter with refs to old objects, which (being ambiguous refs) then prevent the transform.  

Is it possible that an ambiguously scanned C stack is required for some parts of the MPS?  The design intention is that this is NOT required.  How could it be required?  Well, if there are MPS-generated ambiguous stack references that:
  - are a genuine reference that is the only thing preserving an object that must be preserved; or
  - are a genuine reference that is written pre-flip and read post-flip, and may therefore be stale; or
  - nails its referent -- this could be required to prevent some other (non-stack) unmanaged ref becoming stale, even though the on-stack ref is never itself dereferenced.
As a possible example of the first: a newly created object that is to be returned to the client.  Or, it is possible that a hazard would be introduced by skipping parts of the stack and thereby allowing objects to move.

But let's look at the transform case specifically.

The interface version 0.1, where the client provides old-new refs in client objects, we know that all objects that must be preserved (namely the news) are already referenced by the client, and therefore do not require an MPS ambiguous stack reference to protect them from other collections.

For client stack, record stackTop in mpsi.c
For must-save regs, fake stackBot to be just before assembler.
Threads: other threads use traditional stack scanner.  Beware redzones.
How does this work with signals?  Sighandler must have been started on the stack after leaving space for any redzone.  

How may the SS be called, in general?  What was the thread doing?
  - This thread synchronously called the MPS API;
  - Another thread called MPS, and this one was doing something else;
  - Nobody called MPS, but this thread hit a barrier, invoking sighandler or SEH handler;
  - Another thread hit a barrier (invoking sighandler or SEH handler), and this one was doing something else.

Someone will get to the MPS lock first and go in.  Everyone else will be outside.

In the single-threaded case, the rootFlip we care about is when the sole thread synchronously calls mps_arena_transform_objects.  No-one else can get in.  There are no other threads.  So we can globally change the stack-scanner to our special better one, let the rootFlip happen, and then change it back.

Actually, it turns out it's even simpler than that: despite the name, "StackScan()" is only ever called to scan the stack of the thread that entered the MPS.  All other threads have their stacks scanned using separate code in th*.c.  So, when doing a transform, we can make StackScan behave differently and it will not affect how other threads are scanned.

What will be on the stack?

[1] cellAtStackBot;  stackBot = &cellAtStackBot (stored in ThreadContext Root)  
      (client stuff)
[2]      mps_arena_transform() frame, and ArenaEnter
          (mps stuff)
            traceFlip
              (root iterate and scan-method stuff)
                mps_stack_scan_ambig
                  ThreadScan
                    StackScan
[3]                   cellBelowRegs
                      SAVED_REGS                      
[4]                   {read sp here}
                        TraceScanArea( [stackTop, stackBot) )

(More detail:
  traceFlip
   for(rank = ...)
    RootsIterate(&rootFlip, (rfc.rank = rank, &rfc) )
     rootFlip
      if(RootRank(root) == rf->rank)
       traceScanRoot(rf->ts, rf->rank, rf->arena, root)
        traceScanRootRes
         ScanStateInit
         RootScan
          case RootREG:
           (*root->the.reg.scan)
           =
           mps_stack_scan_ambig
            ThreadScan
             StackScan
)

We want to scan between [1] and [2], and between [3] and [4].  But only scan between [1] and [2] if the thread we are trying to scan is the current thread!  Better AVER single thread.  

Luckily, the link between ThreadScan and the ThreadContext root is very tenuous and easy to intercept: RootScan extracts stackBot from the ThreadContext root, and then it gets passed as an argument all the way through root->the.reg.scan > mps_stack_scan_ambig > ThreadScan > StackScan.

Eventually, this special treatment (cleverer scanning) of the ThreadContext root of the MPS-entering thread, either always or just in the case of a transform trace, could be selected by the client by passing a new root-scan function, eg. "mps_threadcontext_scan".  This leaves unmodified clients, that call mps_stack_scan_ambig, without the risk of a surprising change of behaviour.  But perhaps linking to a new MPS build is enough of a surprise that we'll make mps_threadcontext_scan and mps_stack_scan_ambig synonyms.

So, fastest and safest for experimental release, is to leave it called mps_stack_scan_ambig, and in the case of a transform trace:
  sp_1 = stackBot;
  sp_2 = arena->stackAtArenaEnter;
  /* Danger!  No way to check whether stackBot is the bottom of the stack of this *current* thread (which is also the one that entered the arena), or of some completely other thread whose ThreadContext is registered as a root.  From now on we assume there are no such other threads. */
  AVER(single thread);
  TraceScanArea( sp_2, sp_1 );
  ThreadScan(ss, thread, 0);

And in StackScan():
  local cellBelowRegs = 0;
  sp_3 = &cellBelowRegs;
  {Push Regs}
  sp_4 = {read SP};
  if(stackBot != 0) {
    /* stackBot == sp_1  =>  We have been asked to scan whole stack + regs. */
  } else {
    /* stackBot == 0  =>  We have been asked to only scan regs, and not the stack. */
    /* (Presumably someone elsewhere has scanned, or will scan, the stack). */
    stackBot = sp_3;
  }
  TraceScanArea( sp_4, stackBot );
  

____Use AWL?____

Weak key: use to attach extra values to a key-object, without either preserving that key object or using a pointer in it.
Weak value: use to record that a value depends on key, without either preserving that value or using a pointer in key.
What AWL key would we use?
  - the object ref;
  - segbase of its seg (less bad bound if billions of objects?).

The nice things about AWL are:
  - can easily make transform behave like a weak-key hashtable with value-nulling, which is ideal for long-lived transforms;
  - can easily be scannable, to keep news alive;
  - it's a reasonable pool implementation for transform hash-tables to live in;
  - it's well tested etc.

But for 'park, walk, transform' usage, we don't care about weakness, or about preserving news.  It's simpler (less code) to just allocate hash-tables in the ControlPool.


____Parked____

For now, only support transforms while parked.  The client is expected to do this:

  mps_arena_collect()  -- leaves arena parked
  mps_transform_create(&t)
  heapwalk:
  + allocate new and initialise it from old
  + mps_transform_add_oldnew(t, old, new, 1)
  mps_transform_apply(t)
  mps_arena_release()

If a flip happens, the process fails (either gracefully or not).  



____Asides____

//info.ravenbrook.com/project/mps/branch/2010-03-11/vmem/code/trace.c#13 line 450:
"A segment can only be white if it is GC-able."
This should not be true.  There should be nothing to stop a client running part of its object graph through a manually-managed formatted scannable but non-collectable object.  (Presumably the client has some other way to know when to manually reclaim the object).  Preventing condemnation of that object is really evil, because it always acts like a root, even if that's not what the client wants.

RefMan for void mps_arena_collect(mps_arena_t arena) should be mps_res_t (but only error is on whiten, which is always either ResOK or ResUNIMPL, and shurely ResUNIMPL will never happen).

What's the splat value, when a weak-ref gets annulled?  AMC puns that these three are the same:
  - value that format->isMoved() returns if the referent is not a forwarding pointer;
  - (Addr)0;
  - splat value in referring pool.
Splat value should be a property of the format of the referring pool.  For example, some clients might want it still tagged as a pointer.  But it's not.


____MultiTrace____

What if old->new list data is being processed by a trace, and data has been forwarded?  We want a function that lets MPS follow forwarding pointers etc to find the list data.  In other words, detect if it's shielded and/or white, and if so scan it.  TraceSegAccess?

Impose ordering on multiple transform traces.  They must be applied in the specified order.   (Hmmm --- that doesn't work, because they may encounter objects out-of-order.  Hmmm -- that's not meaningful: the object graph will be not as the client told it to be.  Therefore...)  Yes, they must be applied in order.  This is different from a GC-trace, where the passage of the trace leaves the object unchanged (albeit in a new location).


____TODO____

Add mps_arena_transform_objects_list() to mpsicv.c

ArenaTransform external mps_ types should really be cast


____Tests____

Use MPS-allocated memory, and try to get protection (eg. write barrier) on old-list, new-list, transform_done bool.



$Id$
