
____Design____

The client's old->new table must contain managed refs (otherwise might get stale if a flip happens while client is assembling the table).  This means it is part of the object graph.  After a successful transform, all the old refs in this table will have been updated too, so it will look like a new->new table!  This had better not happen *during* the trace, so copy the entire table into the Control pool, and use that copy, not the client-provided one.

Park first.

(Rejected) Unwinding: if we have started a trace but found an ambig (non-updateable) ref to an old object, how do we abort the trace?  We don't.  (Too messy: there may be things like nailboards allocated).  Rejected.

Don't unwind: do trace-band Ambig, checking each fixed ref against the old list.  At the end of trace-band Ambig, if we ambiguously-fixed any old-list ref, then we cannot transform, but we *continue* the trace with transforming "off": it is just a non-transforming collection.  Whereas if we did not encounter any old-ref, then we have a green light for transforming (because all remaining refs are updateable), so we enter trace-band Exact with transforming "on".

Optimisations (whiteset etc) might prevent fix fixing.  What are these optimisations?  How do we turn them off appropriately?  Condemn segs holding all old objects should do it correctly, cf. traceStartCollectAll() for a seg-by-seg Whiten operation.

Intercept fix.  Function called is (ss)->fix, and is either TraceFix or TraceFixEmergency.

TraceStruct could know the fix function for this trace.  Aha, but Scan is for a whole TraceSet, not just a single trace.  How is ScanStateInit called?

Double-update: intercept fix, replace old by new, and continue to fix the new ref.  New may itself be condemned and so move (eg. if it's on same seg as an old).  

Will this upset any ref/summary asserts?

Emergency mode.  What happens if we enter emergency mode during the transform trace?  During a double-update?  See "if Fix fails, ref must be unchanged" in TraceFix().

(Rejected) Instead of double-update, how about overwriting old-obj with a forwarding pointer to new-obj.  Requires double snap-out (as would, I think, be required for multiple traces).  But only PoolAMC formats expect to use fwd/move & isfwd/isMoved, and only PoolAMC resolves forwarding pointers.  So would only support olds in PoolAMC.  Rejected.

Is it thread-safe?  If thread 1 is about to call transform(), but just after it pushes args on the stack it gets preempted and thread 2 starts and triggers a new trace.  Yup, should be ok.

Buffers: what if there's an old ptr in a buffer (allocation point)?

How can TraceAddWhite fail?  Basically it can't currently, apart from ResUNIMPL.



____Asides____

//info.ravenbrook.com/project/mps/branch/2010-03-11/vmem/code/trace.c#13 line 450:
"A segment can only be white if it is GC-able."
This should not be true.  There should be nothing to stop a client running part of its object graph through a manually-managed formatted scannable but non-collectable object.  (Presumably the client has some other way to know when to manually reclaim the object).  Preventing condemnation of that object is really evil, because it always acts like a root, even if that's not what the client wants.

RefMan for void mps_arena_collect(mps_arena_t arena) should be mps_res_t (but only error is on whiten, which is always either ResOK or ResUNIMPL, and shurely ResUNIMPL will never happen).

What's the splat value, when a weak-ref gets annulled?  AMC puns that these three are the same:
  - value that format->isMoved() returns if the referent is not a forwarding pointer;
  - (Addr)0;
  - splat value in referring pool.
Splat value should be a property of the format of the referring pool.  For example, some clients might want it still tagged as a pointer.  But it's not.


____MultiTrace____

What if old->new list data is being processed by a trace, and data has been forwarded?  We want a function that lets MPS follow forwarding pointers etc to find the list data.  In other words, detect if it's shielded and/or white, and if so scan it.  TraceSegAccess?

Impose ordering on multiple transform traces.  They must be applied in the specified order.   (Hmmm --- that doesn't work, because they may encounter objects out-of-order.  Hmmm -- that's not meaningful: the object graph will be not as the client told it to be.  Therefore...)  Yes, they must be applied in order.  This is different from a GC-trace, where the passage of the trace leaves the object unchanged (albeit in a new location).


____TODO____

Add mps_arena_transform_objects_list() to mpsicv.c

ArenaTransform external mps_ types should really be cast


____Tests____

Use MPS-allocated memory, and try to get protection (eg. write barrier) on old-list, new-list, transform_done bool.



$Id$
