__Prototype__

mps_res_t mps_arena_transform_objects_list(
  mps_bool_t  *transform_done_o,
  mps_arena_t arena,
  mps_addr_t  *old_list,
  size_t      old_list_count,
  mps_addr_t  *new_list,
  size_t      new_list_count);


__Arguments__

transform_done_o: (output parameter) a pointer to an mps_bool_t

arena: the arena

old_list: pointer to first element of an array of references to 'old' objects; the array element type is "mps_addr_t";

old_list_count: number of elements in old_list array.

new_list: pointer to first element of an array of references to 'new' objects; the array element type is "mps_addr_t";

new_list_count: number of elements in new_list array.


__Returned Values__

If the transform was performed, *transform_done_o is set to 1, and the return value is MPS_RES_OK.

If the transform was not performed because there were non-transformable references to old objects, *transform_done_o is set to 0, and the return value is MPS_RES_OK.

If the MPS was unable to attempt the transform, *transform_done_o is set to 0, and the return value indicates why.  


__Description__

The MPS attempts to replace every managed reference to an old object, with a reference to the corresponding new object, throughout the arena, thus 'transforming' each old object into its new counterpart.  (A "managed reference" is one which the MPS knows is part of the object graph, such as references in declared roots, and references in managed objects with a format-scan method).

Existing references to new objects are unchanged.  (That is: they will still refer to the new object; the pointer value may of course change if the object is in a moving pool).

If the transform succeeds, all managed references to old objects are transformed.  This includes all references in old_list.  

If the transform succeeds, no managed references to old objects remain, and the old objects may be collected.  If an old object was registered for finalization, a finalization message is *not* produced: rather, the corresponding new object is registered for finalization.  A weak reference to an old object is transformed into a weak reference to the corresponding new object.

Ambiguous references cannot be transformed.  If there is a managed ambiguous reference to any old object, the entire transform fails, no references are changed, *transform_done_o is set to 0, and the return value is MPS_RES_OK.  Currently: references in a root declared with mps_rank_ambig(), and references in a root created with mps_root_create_reg and mps_stack_scan_ambig, are ambiguous.  To avoid failure for this reason, do not store references to old objects in any ambiguous root, and ensure there are no intentional references to old objects on the stack.  

Note that it is in general impossible to prevent accidental 'references' to old objects appearing on the stack by coincidence, such as in arbitrary binary data.  Therefore, always check the returned "transform_done" value, and handle the 0 (FALSE) case appropriately.

When mps_arena_transform_objects_list() finishes, it leaves the MPS arena parked (just like mps_arena_collect()).  To allow automatic collections to start up again, call mps_arena_release().

Constraints:

The mps_bool_t pointed to by transform_done_o may be anywhere (managed or unmanaged).

The old_list and new_list arrays must be managed.  (Otherwise the references may become stale).  The arrays should either be allocated from MPS memory and have a format-scan method, or be externally allocated and declared to the MPS as exact roots.  

Both arrays must have the same number of elements, that is: old_list_count and new_list_count must be equal.

Old and new objects must have been allocated from MPS memory.  They may be in any pool or pools.  Restriction: objects must have been allocated in a pool from an automatic (that is: garbage collected) pool class.  [This restriction could be removed.  RHSK 2010-11-05].

[If I change the interface to use a linked list...] Each list must be terminated with next = NULL; circular lists are not permitted and may cause undefined results.

An old object should be referenced in old_list exactly once.  (However, currently, if it is referenced in old_list more than once, only the first entry is used for the transform; later entries are not used, but may be checked for constraint violations).  

A new object may be referenced in new_list more than once.  It is permitted for several different old objects to all transform to the same new object.  

An entry where the old object reference is NULL (0) is permitted.  No transform is performed for this entry (but it may be checked for other constraint violations).  (Note that this permits attempting to transform weakly-referenced cached objects, by using an old_list with weak references).

An entry where the new object reference is NULL (0) is not permitted.  

Null-transform entries are permitted, where an object in old_list is also listed as the corresponding new object in new_list (that is: the old and new references are the same).  No transform is performed for these objects.

The transform must be idempotent, that is: applying it more than once has no further effect.  Therefore, except for null-transform entries, the sets of old and new references must be disjoint (that is: no object may appear in both old and new lists).  This means, for example, that it is not possible to swap two objects in a single transform operation.


__Example__

  mps_res_t res;
  mps_bool_t transform_done;
  size_t     i;
  mps_addr_t old_list[100];
  mps_addr_t new_list[100];
  mps_root_t old_list_root;
  mps_root_t new_list_root;
  
  for(i = 0; i < 100; i++) {
    old_list[i] = NULL;
    new_list[i] = NULL;
  }
  
  res = mps_root_create_table(&old_list_root, arena, 
    MPS_RANK_EXACT, (mps_rm_t)0, old_list, (size_t)100);
  res = mps_root_create_table(&new_list_root, arena, 
    MPS_RANK_EXACT, (mps_rm_t)0, new_list, (size_t)100);

  old_list[0] = Old_0;
  old_list[1] = Old_1;
  new_list[0] = New_0;
  new_list[1] = New_1;
  
  res = mps_arena_transform_objects_list(
    &transform_done, arena, old_list, 2, new_list, 2);

  handle_mps_res(res);

  if(transform_done) {
    /* all refs to Old_0 have been transformed to New_0, and Old_1 to New_1 */
    user_announce("Patch Succeeded!");
  } else {
    if(user_exit("Sorry, patching requires restart.  Restart now?  Y/N")) {
      exit();
    }
  }

$Id$
